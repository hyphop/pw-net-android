#include <android/log.h>
#include <android/native_window.h>
#include <android/native_window_jni.h>
#include <android_native_app_glue.h>
#include <arpa/inet.h>
#include <errno.h>
#include <math.h>
#include <netdb.h>
#include <pthread.h>
#include <sched.h>
#include <stdatomic.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <time.h>
#include <unistd.h>
#include <android/looper.h>

#define TAG "MiniNative"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__)

// -------- tiny 5x7 bitmap font (ASCII 32..127), 5 columns/char, MSB=top row
static const uint8_t FONT5x7[96][5] = {
  // space..'~' (you can expand; minimal subset includes enough for our string)
  {0,0,0,0,0}, {0x00,0x00,0x5F,0x00,0x00}, {0x00,0x03,0x00,0x03,0x00}, {0x14,0x7F,0x14,0x7F,0x14},
  {0x24,0x2A,0x7F,0x2A,0x12}, {0x23,0x13,0x08,0x64,0x62}, {0x36,0x49,0x55,0x22,0x50}, {0x00,0x05,0x03,0x00,0x00},
  {0x00,0x1C,0x22,0x41,0x00}, {0x00,0x41,0x22,0x1C,0x00}, {0x14,0x08,0x3E,0x08,0x14}, {0x08,0x08,0x3E,0x08,0x08},
  {0x00,0x50,0x30,0x00,0x00}, {0x08,0x08,0x08,0x08,0x08}, {0x00,0x60,0x60,0x00,0x00}, {0x20,0x10,0x08,0x04,0x02},
  {0x3E,0x51,0x49,0x45,0x3E}, {0x00,0x42,0x7F,0x40,0x00}, {0x72,0x49,0x49,0x49,0x46}, {0x21,0x41,0x49,0x4D,0x33},
  {0x18,0x14,0x12,0x7F,0x10}, {0x27,0x45,0x45,0x45,0x39}, {0x3C,0x4A,0x49,0x49,0x31}, {0x41,0x21,0x11,0x09,0x07},
  {0x36,0x49,0x49,0x49,0x36}, {0x46,0x49,0x49,0x29,0x1E}, {0x00,0x36,0x36,0x00,0x00}, {0x00,0x56,0x36,0x00,0x00},
  {0x08,0x14,0x22,0x41,0x00}, {0x14,0x14,0x14,0x14,0x14}, {0x00,0x41,0x22,0x14,0x08}, {0x02,0x01,0x59,0x09,0x06},
  {0x3E,0x41,0x5D,0x59,0x4E}, {0x7E,0x11,0x11,0x11,0x7E}, {0x7F,0x49,0x49,0x49,0x36}, {0x3E,0x41,0x41,0x41,0x22},
  {0x7F,0x41,0x41,0x22,0x1C}, {0x7F,0x49,0x49,0x49,0x41}, {0x7F,0x09,0x09,0x09,0x01}, {0x3E,0x41,0x49,0x49,0x7A},
  {0x7F,0x08,0x08,0x08,0x7F}, {0x00,0x41,0x7F,0x41,0x00}, {0x20,0x40,0x41,0x3F,0x01}, {0x7F,0x08,0x14,0x22,0x41},
  {0x7F,0x40,0x40,0x40,0x40}, {0x7F,0x02,0x0C,0x02,0x7F}, {0x7F,0x04,0x08,0x10,0x7F}, {0x3E,0x41,0x41,0x41,0x3E},
  {0x7F,0x09,0x09,0x09,0x06}, {0x3E,0x41,0x51,0x21,0x5E}, {0x7F,0x09,0x19,0x29,0x46}, {0x26,0x49,0x49,0x49,0x32},
  {0x01,0x01,0x7F,0x01,0x01}, {0x3F,0x40,0x40,0x40,0x3F}, {0x1F,0x20,0x40,0x20,0x1F}, {0x7F,0x20,0x18,0x20,0x7F},
  {0x63,0x14,0x08,0x14,0x63}, {0x07,0x08,0x70,0x08,0x07}, {0x61,0x51,0x49,0x45,0x43},
  {0x00,0x7F,0x41,0x41,0x00}, {0x02,0x04,0x08,0x10,0x20}, {0x00,0x41,0x41,0x7F,0x00}, {0x04,0x02,0x01,0x02,0x04},
  {0x40,0x40,0x40,0x40,0x40}, {0x00,0x01,0x02,0x00,0x00},
  {0x20,0x54,0x54,0x54,0x78}, {0x7F,0x48,0x44,0x44,0x38}, {0x38,0x44,0x44,0x44,0x28}, {0x38,0x44,0x44,0x48,0x7F},
  {0x38,0x54,0x54,0x54,0x18}, {0x08,0x7E,0x09,0x01,0x02}, {0x0C,0x52,0x52,0x52,0x3E}, {0x7F,0x08,0x04,0x04,0x78},
  {0x00,0x44,0x7D,0x40,0x00}, {0x20,0x40,0x44,0x3D,0x00}, {0x7F,0x10,0x28,0x44,0x00}, {0x00,0x41,0x7F,0x40,0x00},
  {0x7C,0x04,0x18,0x04,0x78}, {0x7C,0x08,0x04,0x04,0x78}, {0x38,0x44,0x44,0x44,0x38}, {0x7C,0x14,0x14,0x14,0x08},
  {0x08,0x14,0x14,0x18,0x7C}, {0x7C,0x08,0x04,0x04,0x08}, {0x48,0x54,0x54,0x54,0x20}, {0x04,0x3F,0x44,0x40,0x20},
  {0x3C,0x40,0x40,0x20,0x7C}, {0x1C,0x20,0x40,0x20,0x1C}, {0x3C,0x40,0x30,0x40,0x3C}, {0x44,0x28,0x10,0x28,0x44},
  {0x0C,0x50,0x50,0x50,0x3C}, {0x44,0x64,0x54,0x4C,0x44}, {0x00,0x08,0x36,0x41,0x00}, {0x00,0x00,0x7F,0x00,0x00},
  {0x00,0x41,0x36,0x08,0x00}, {0x08,0x04,0x08,0x10,0x08}
};
// -------- simple pixel put & text draw onto ANativeWindow buffer (ARGB_8888)
static inline void put_px(uint32_t *fb, int W, int x, int y, uint32_t argb) {
  if ((unsigned)x < (unsigned)W && y >= 0) fb[y*(size_t)W + x] = argb;
}
static void draw_char(uint32_t *fb, int W, int x, int y, char c, uint32_t fg) {
  if (c < 32 || c > 127) c = '?';
  const uint8_t *col = FONT5x7[c - 32];
  for (int i=0;i<5;i++) {
    uint8_t bits = col[i];
    for (int j=0;j<7;j++) if (bits & (1<<(6-j))) put_px(fb, W, x+i, y+j, fg);
  }
}
static void draw_text(uint32_t *fb, int W, int x, int y, const char *s, uint32_t fg) {
  for (int i=0; s[i]; ++i) { draw_char(fb, W, x + i*6, y, s[i], fg); }
}
// -------- TCP sine generator thread
typedef struct {
  atomic_int run;
  char host[128];
  int port;
} tx_cfg_t;

static void ms_sleep(int ms){
  struct timespec ts; ts.tv_sec = ms/1000; ts.tv_nsec = (ms%1000)*1000000L; nanosleep(&ts,NULL);
}

static void *tx_thread(void *arg) {
  tx_cfg_t *cfg = (tx_cfg_t*)arg;
  const int rate=48000, ch=2;
  const double two_pi=6.283185307179586, freq=440.0;
  double phase=0.0, step = two_pi*freq/(double)rate;
  const int frames_per_chunk = 480; // 10 ms
  int16_t buf[frames_per_chunk * ch];

  while (atomic_load(&cfg->run)) {
    // connect (retry until OK)
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if (fd < 0) { ms_sleep(500); continue; }
    struct hostent *he = gethostbyname(cfg->host);
    if (!he) { close(fd); ms_sleep(1000); continue; }
    struct sockaddr_in sa; memset(&sa,0,sizeof(sa));
    sa.sin_family = AF_INET;
    memcpy(&sa.sin_addr, he->h_addr, he->h_length);
    sa.sin_port = htons(cfg->port);

    if (connect(fd, (struct sockaddr*)&sa, sizeof(sa)) != 0) {
      close(fd); ms_sleep(500); continue;
    }
    LOGI("TCP connected to %s:%d", cfg->host, cfg->port);

    // stream loop
    struct timespec t0; clock_gettime(CLOCK_MONOTONIC, &t0);
    uint64_t sent_frames = 0;
    while (atomic_load(&cfg->run)) {
      // fill 10 ms of stereo S16LE
      for (int i=0;i<frames_per_chunk;i++) {
        int16_t s = (int16_t)(sin(phase) * 30000.0);
        phase += step; if (phase >= two_pi) phase -= two_pi;
        buf[2*i+0] = s; // L
        buf[2*i+1] = s; // R
      }
      size_t need = sizeof(buf), off=0;
      while (off < need) {
        ssize_t n = send(fd, ((uint8_t*)buf)+off, need-off, 0);
        if (n <= 0) goto reconnect;
        off += (size_t)n;
      }
      sent_frames += frames_per_chunk;

      // pace to 48k
      double secs = (double)sent_frames / (double)rate;
      struct timespec now; clock_gettime(CLOCK_MONOTONIC, &now);
      double elapsed = (now.tv_sec - t0.tv_sec) + (now.tv_nsec - t0.tv_nsec)/1e9;
      if (elapsed < secs) {
        int ms = (int)((secs - elapsed)*1000.0);
        if (ms > 0) ms_sleep(ms);
      }
    }
reconnect:
    LOGE("TCP reconnect...");
    close(fd);
    ms_sleep(200);
  }
  return NULL;
}

// -------- rendering (fill background + text)
static void render(ANativeWindow *win) {
  if (!win) return;
  ANativeWindow_Buffer buf;
  if (ANativeWindow_lock(win, &buf, NULL) != 0) return;

  int W = buf.width, H = buf.height;
  uint32_t *fb = (uint32_t*)buf.bits;
  // clear (dark)
  for (int y=0;y<H;y++) {
    for (int x=0;x<W;x++) fb[y*(size_t)W+x] = 0xFF101418;
  }
  const char *line1 = "MiniNative (no Java)";
  const char *line2 = "TCP 48kHz 16-bit stereo -> 192.168.1.131:9999";
  draw_text(fb, W, 10, 20, line1, 0xFFFFFFFF);
  draw_text(fb, W, 10, 40, line2, 0xFF66CCFF);
  ANativeWindow_unlockAndPost(win);
}

// -------- app entry
void android_main(struct android_app* app) {
  app->onAppCmd = NULL;
  LOGI("android_main start");

  // start TX thread
  tx_cfg_t cfg; atomic_init(&cfg.run, 1);
  snprintf(cfg.host, sizeof(cfg.host), "192.168.1.131");
  cfg.port = 9999;
  pthread_t th; pthread_create(&th, NULL, tx_thread, &cfg);

  int events, ident; struct android_poll_source* source;
  while (1) {
    /* drain all pending events without blocking */
    while ((ident = ALooper_pollOnce(0, NULL, &events, (void**)&source)) >= 0) {
      if (source) source->process(app, source);
      if (app->destroyRequested) { atomic_store(&cfg.run, 0); goto done; }
    }
    if (app->window) render(app->window);
    ms_sleep(16); /* ~60 fps pace */
  }

done:
  LOGI("stopping...");
  atomic_store(&cfg.run, 0);
  pthread_join(th, NULL);
}
